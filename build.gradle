plugins {
    id 'com.github.johnrengelman.shadow' version '2.0.4'
    id 'java'
    id 'org.ajoberstar.grgit' version '2.3.0' apply false
}

import org.ajoberstar.grgit.Grgit

repositories {
    jcenter()
    mavenCentral()
}

// Note:  For this setup to work you must follow the instructions outlined in the
//       checker manual Section 25.3 "Building from Source"
// http://types.cs.washington.edu/checker-framework/current/checkers-manual.html#build-source

ext {
    assert JavaVersion.current() == JavaVersion.VERSION_1_8: "Set JAVA_HOME to JDK 8. Current version is ${JavaVersion.current()}"
    parentDir = file("${projectDir}/../").absolutePath
    checkerFrameworkPath = System.getenv('CHECKERFRAMEWORK') ?: "${parentDir}/checker-framework"
    checkerJar = "${checkerFrameworkPath}/checker/dist/checker.jar"
    afu = "${parentDir}/annotation-tools/annotation-file-utilities"

    formatScriptsHome = "${projectDir}/scripts/.run-google-java-format"
}

println '===================================='
println '    Checker Framework Inference     '
println '===================================='
println ''
println '-------------------------------'
println 'Important Environment Variables'
println '-------------------------------'
println 'PARENTDIR       : ' + parentDir
println 'CHECKERFRAMEWORK: ' + checkerFrameworkPath

repositories {
    jcenter()
    mavenCentral()
}

dependencies {

    compile files("${checkerJar}")
    compile 'org.plumelib:options:0.3.1'
    // Serialize constraints
    compile 'com.googlecode.json-simple:json-simple:1.1'
    // Pretty print serialized constraints
    compile 'com.google.code.gson:gson:1.7.2'

    compile 'org.ow2.sat4j:org.ow2.sat4j.core:2.3.4'
    compile 'org.ow2.sat4j:org.ow2.sat4j.maxsat:2.3.4'

    testCompile fileTree(dir: "${checkerFrameworkPath}/framework-test/build/libs", include: "framework-test-*.jar")
    // Mocking library. Used in a couple tests
    testCompile 'org.mockito:mockito-all:2.0.2-beta'
    testCompile 'junit:junit:4.12'
}

sourceSets {
    main {
        java {
            srcDirs = ["src"]
        }

        resources {
            srcDir "src"
            include "**/*.astub"
        }
    }

    test {
        java {
            srcDirs = ["tests"]
        }
    }
}

test {
    dependsOn(shadowJar)

    systemProperties 'path.afu.scripts': "${afu}/scripts",
            'use.hacks': true

    systemProperties += [JDK_JAR: "${checkerFrameworkPath}/checker/dist/jdk8.jar"]

    if (project.hasProperty('emit.test.debug')) {
        systemProperties += ["emit.test.debug": 'true']
    }

    testLogging {
        // Always run the tests
        outputs.upToDateWhen { false }
        // The following prints out each time a test is passed.
        // events "passed", "skipped", "failed", "standardOut", "standardError"

        // Show the found unexpected diagnostics and expected diagnostics not found.
        exceptionFormat "full"
    }

    // After each test, print a summary.
    afterSuite { desc, result ->
        if (desc.getClassName() != null) {
            long mils = result.getEndTime() - result.getStartTime()
            double seconds = mils / 1000.0

            println "Testsuite: ${desc.getClassName()}\n" +
                    "Tests run: ${result.testCount}, " +
                    "Failures: ${result.failedTestCount}, " +
                    "Skipped: ${result.skippedTestCount}, " +
                    "Time elapsed: ${seconds} sec\n"
        }

    }
}

compileJava {
    options.compilerArgs = [
            '-implicit:class',
            '-Awarns',
            '-Xmaxwarns', '10000',
            // Can't use this because JSON library contains raw types:
            // '-Xlint:unchecked',
            '-Xlint:deprecation',
            '-Werror',
    ]
}

// Exclude parts of the build directory that don't include classes from being packaged in
// the jar file.
// IMPORTANT: If "libs" is packaged in the JAR file you end up with an infinitely
// recursive jar task that will fill up your hard drive (eventually)
jar {
    description = 'Makes a jar with ONLY the classes compiled for checker ' +
            'framework inference and NONE of its dependencies'
    archiveName = "checker-framework-inference.jar"
    manifest.attributes("Main-Class": "checkers.inference.InferenceLauncher")
    exclude("dependency-cache", "libs", "tmp")
}

shadowJar {
    description 'Creates the "fat" checker.jar in dist'
    destinationDir = file("${projectDir}/dist")
    archiveName = "checker-framework-inference.jar"
}

task getCodeFormatScripts {
  description "Obtain the run-google-java-format scripts"
  doLast {
    if (! new File(formatScriptsHome).exists()) {
      def rgjfGit = Grgit.clone(dir: formatScriptsHome, uri: 'https://github.com/plume-lib/run-google-java-format.git')
    } else {
      def rgjfGit = Grgit.open(dir: formatScriptsHome)
      rgjfGit.pull()
    }
  }
}

task pythonIsInstalled(type: Exec) {
  description "Check that the python executable is installed."
  executable = "python"
  args "--version"
}

/**
 * Returns a list of all the Java files that should be formatted for the given project. These are:
 *
 * All java files in the main sourceSet.
 * All java files in the tests directory that compile.
 *
 * @return a list of all Java files that should be formatted
 */
List<String> getJavaFilesToFormat() {
    List<File> javaFiles = new ArrayList<>();
    sourceSets.forEach { set ->
        javaFiles.addAll(set.java.files)
    }
    // Collect all java files in tests directory
    fileTree("${projectDir}/tests").visit { details ->
        if (details.name.endsWith('java')) {
            javaFiles.add(details.file)
        }
    }
    // Collect all java files in testdata directory
    fileTree("${projectDir}/testdata").visit { details ->
        if (!details.path.contains("tmp/annotated-source") && details.name.endsWith('java')) {
            javaFiles.add(details.file)
        }
    }

    List<String> args = new ArrayList<>();
    for (File f : javaFiles) {
        args += f.absolutePath
    }
    return args
}

task checkBasicStyle(group: 'Format') {
    description 'Check basic style guidelines.  Not related to Checkstyle tool.'
    String[] ignoreDirectories = ['.git',
                                  '.gradle',
                                  '.settings',
                                  'annotated',
                                  'build',
                                  'dist',
                                  'gradle',
                                  'lib',
                                  'tmp']
    String[] ignoreFilePatterns = [
            '*.class',
            '*.jar',
            '*.log',
            '*.pdf',
            '*.txt',
            '*.so',
            '*.swp']
    doLast {
        FileTree tree = fileTree(dir: projectDir)
        for (String dir : ignoreDirectories) {
            tree.exclude "**/${dir}/**"
        }
        for (String file : ignoreFilePatterns) {
            tree.exclude "**/${file}"
        }
        boolean failed = false
        tree.visit {
            if (!it.file.isDirectory()) {
                int isBlankLine
                it.file.eachLine { line ->
                    if (line.endsWith(' ')) {
                        println("Trailing whitespace: ${it.file.absolutePath}")
                        failed = true
                    }
                    if (!line.startsWith('\\') &&
                            (line.matches('^.* (else|finally|try)\\{}.*$')
                                    || line.matches('^.*}(catch|else|finally) .*$')
                                    || line.matches('^.* (catch|for|if|while)\\('))) {
                        // This runs on non-java files, too.
                        println("Missing space: ${it.file.absolutePath}")
                        failed = true
                    }
                    if (line.isEmpty()) {
                        isBlankLine++;
                    } else {
                        isBlankLine = 0;
                    }
                }

                if (isBlankLine > 1) {
                    println("Blank line at end of file: ${it.file.absolutePath}")
                    failed = true
                }

                RandomAccessFile file
                try {
                    file = new RandomAccessFile(it.file, 'r')
                    int end = file.length() - 1;
                    if (end > 0) {
                        file.seek(end)
                        byte last = file.readByte()
                        if (last != '\n') {
                            println("Missing newline at end of file: ${it.file.absolutePath}")
                            failed = true
                        }
                    }
                } finally {
                    if (file != null) {
                        file.close()
                    }
                }
            }
        }
        if (failed) {
            throw new GradleException("Files do not meet basic style guidelines.")
        }
    }
}

task checkFormat(type: Exec, dependsOn: [getCodeFormatScripts, pythonIsInstalled], group: 'Format') {
    description 'Check whether the source code is properly formatted'
    executable 'python'
    doFirst {
        args += "${formatScriptsHome}/check-google-java-format.py"
        args += "--aosp" // 4 space indentation
        args += getJavaFilesToFormat()
    }
    ignoreExitValue = true
    doLast {
        if (execResult.exitValue != 0) {
            throw new RuntimeException('Found improper formatting, try running:  ./gradlew reformat"')
        }
    }
}

task reformat(type: Exec, dependsOn: [getCodeFormatScripts, pythonIsInstalled], group: 'Format') {
    description 'Format the Java source code'
    executable 'python'
    doFirst {
        args += "${formatScriptsHome}/run-google-java-format.py"
        args += "--aosp" // 4 space indentation
        args += getJavaFilesToFormat()
    }
}

task dependenciesJar(type: Jar) {
    description 'Create a jar file with all the dependencies.'
    from {
        configurations.compile.collect { it.isDirectory() ? it : zipTree(it) }
        configurations.testCompile.collect { it.isDirectory() ? it : zipTree(it) }
    }
    archiveName 'dependencies.jar'
    destinationDir file("${projectDir}/dist/")
}

task dist(dependsOn: shadowJar, type: Copy) {
    description = "If your Checker Framework project is fully built, this task " +
            "will build checker-framework-inference.jar, copy all the relevant runtime jars into " +
            "the dist directory."
    from files(
            "${checkerFrameworkPath}/checker/dist/jdk8.jar",
            "${checkerFrameworkPath}/checker/dist/checker.jar",
            "${checkerFrameworkPath}/checker/dist/checker-qual.jar",
            "${checkerFrameworkPath}/checker/dist/javac.jar",
    )
    into file('dist')
}

tasks.clean {
    delete += "build/libs/checker-framework-inference.zip"
    delete += "jdk8.jar"
    delete += "javac.jar"
    delete += fileTree('dist') {
        include '**/*.jar'
    }
}


task release(type: Zip) {
    from('src') {
        into('release/src')
    }

    from('dist') {
        into('release/dist')
    }
    from('scripts') {
        into('release/scripts')
        include '*.py'
    }

    baseName = 'release'
}


task testCheckerInferenceScript(type: Exec, dependsOn: dist) {
    description 'Basic sanity check of scripts/inference'
    executable './scripts/inference'
    args = ['--mode', 'TYPECHECK',
            '--checker', 'ostrusted.OsTrustedChecker',
            '--solver', 'checkers.inference.solver.PropagationSolver',
            'testdata/ostrusted/Test.java']
}

task testCheckerInferenceDevScript(type: Exec, dependsOn: [dist, dependenciesJar]) {
    description 'Basic sanity check of scripts/inference-dev'
    executable './scripts/inference-dev'
    args = ['--mode', 'INFER',
            '--checker', 'interning.InterningChecker',
            '--solver', 'checkers.inference.solver.MaxSat2TypeSolver',
            'testdata/interning/MapAssignment.java']
}

task etags {
    doLast {
        def sources = (sourceSets.main.java).getFiles().collect({ src -> src.getPath() }).sort()
        def sourcesStr = sources.inject(null, { acc, source -> acc ? acc + " " + source : source })

        def proc = "etags ${sourcesStr} ".execute()
        proc.in.eachLine { line -> println line }
        proc.err.eachLine { line -> println 'ERROR: ' + line }
        proc.waitFor()
    }
}

task tags(dependsOn: etags)

task countHacks(type: Exec) {
    commandLine "bash", "-c", "grep -r 'InferenceMain.isHackMode(' src/ | wc -l"
}
